% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/singleband-many-to-many.R
\name{singleband_m2m}
\alias{singleband_m2m}
\alias{hampel_filter}
\title{Temporal filtering and smoothing for raster time series}
\usage{
singleband_m2m(
  x,
  m2m_fun,
  outfile,
  config_options,
  creation_options,
  quiet,
  nsplits,
  recollect
)

hampel_filter(k = 1L, t0 = 3, impute_na = FALSE)
}
\arguments{
\item{x}{A \code{vrt_collection_warped} object. All images must be aligned to the
same grid (use \code{\link[=vrt_warp]{vrt_warp()}} first).}

\item{m2m_fun}{A function that operates on time series data. The function
receives a matrix where rows represent time steps and columns represent
pixels, and must return a matrix of the same dimensions. See \code{hampel_filter}
for an example. Calculations are performed independently for each band.}

\item{outfile}{Output file path(s). Can be a single path (used as template)
or a vector of paths (one per time step). Defaults to temporary files.}

\item{config_options}{A named character vector of GDAL configuration options.
See \code{gdal_config_options()}.}

\item{creation_options}{A named character vector of GDAL creation options for
output files. See \code{gdal_creation_options()}.}

\item{quiet}{Logical. If \code{FALSE}, displays a progress bar during processing.}

\item{nsplits}{Integer specifying the number of spatial tiles to process. If
\code{NULL} (default), automatically determines optimal tiling based on input
dimensions, available memory, and number of parallel workers.}

\item{recollect}{Logical. If \code{TRUE}, returns a \code{vrt_collection} object
containing the processed images. If \code{FALSE} (default), returns a character
vector of output file paths.}

\item{k}{The number of neighboring points to consider on each side of the
current point. window length 2*k+1 in indices.}

\item{t0}{threshold, default is 3 (Pearson's rule), see below.}

\item{impute_na}{Logical indicating whether to impute NA values. If \code{TRUE},
the function will impute NA values using the nearest prior non-NA value. If
\code{FALSE}, NA values will be returned in their original positions.}
}
\value{
If \code{recollect = FALSE}, a character vector of output file paths (one
per time step). If \code{recollect = TRUE}, a \code{vrt_collection} object.

A function to be used with \code{singleband_m2m()} to remove outliers
from a raster time series.
}
\description{
Apply temporal operations to each pixel's time series in a
warped VRT collection. This function processes each band independently,
applying a user-defined function across the temporal dimension (e.g.,
filtering outliers, smoothing, gap-filling).

\code{hampel_filter} is used to create a function to filter band-level
outliers in time-series using the Hampel filter. to be provided to
\code{singleband_m2m()}.
}
\details{
\subsection{Processing Model}{

\code{singleband_m2m()} materializes the virtual raster collection by:
\enumerate{
\item \strong{Spatial tiling}: Divides the spatial extent into tiles for efficient
memory usage
\item \strong{Band-wise processing}: For each band and tile, extracts the complete
time series (all images)
\item \strong{Temporal operations}: Applies \code{m2m_fun} to the time series matrix
(rows = time, cols = pixels)
\item \strong{Output writing}: Writes filtered results to disk as GeoTIFF files
}
}

\subsection{Common Use Cases}{
\itemize{
\item \strong{Outlier removal}: Remove cloud contamination or sensor artifacts using
\code{\link[=hampel_filter]{hampel_filter()}}
\item \strong{Temporal smoothing}: Apply moving average or median filters
\item \strong{Gap filling}: Interpolate missing values in time series
\item \strong{Temporal compositing}: Create median/mean composites while preserving
all time steps
}
}

\subsection{Performance Considerations}{
\itemize{
\item Processing is parallelized if \code{mirai} daemons are active (see
\code{daemons}\link[mirai:mirai]{mirai::mirai}).
\item Automatic tiling balances memory usage against I/O overhead
\item Each output image retains original metadata (timestamps, band descriptions)
\item Use \code{recollect = TRUE} to chain with additional VRT operations
}
}

(details from the \code{pracma::hampel}) The ‘median absolute deviation’ computation is
done in the (-k...k) vicinity of each point at least k steps away from the
end points of the interval. At the lower and upper end the time series values
are preserved.

A high threshold makes the filter more forgiving, a low one will declare
more points to be outliers. t0<-3 (the default) corresponds to Ron Pearson's
3 sigma edit rule, t0<-0 to John Tukey's median filter.

The implementation of the hampel filter is based on the pracma package but
implemented in C++. It also handles NA values differently, First, NA values
are removed from the data before applying the filter. If \code{impute_na} is
\code{TRUE}, the function will impute NA values using the nearest prior non-NA
value. If \code{impute_na} is \code{FALSE}, NA values will be returned in their
original positions.
}
\examples{
\dontshow{if (interactive()) withAutoprint(\{ # examplesIf}
#  Set up asynchronous workers to parallelise vrt_collect and vrt_set_maskfun
mirai::daemons(4)

bbox <- gdalraster::bbox_from_wkt(
  wkt = "POINT (144.3 -7.6)",
  extend_x = 0.05,
  extend_y = 0.05
)

te <- bbox_to_projected(bbox)
trs <- attr(te, "wkt")

s2_stac <- hls_stac_query(
  bbox = bbox,
  start_date = "2023-01-01",
  end_date = "2024-12-31",
  max_cloud_cover = 40,
  assets = c("B02", "B03", "B04", "Fmask")
)
# number of items:
length(s2_stac$features)

collection <- vrt_collect(s2_stac) |>
  vrt_set_maskfun(
    mask_band = "Fmask",
    mask_values = c(0, 1, 2, 3),
    build_mask_pixfun = build_bitmask()
  ) |>
  vrt_warp(t_srs = trs, te = te, tr = c(30, 30))

# Apply Hampel filter to remove outliers
filtered <- collection |>
  singleband_m2m(
    m2m_fun = hampel_filter(k = 3L, t0 = 0, impute_na = TRUE),
    recollect = TRUE
  )
withr::with_par(list(mfrow = c(2, 1)), {
  plot(collection, item = 10, bands = c(3, 2, 1), main = "Original")
  plot(filtered, item = 10, bands = c(3, 2, 1), main = "Hampel Filtered")
})

# Custom temporal function: 5-image moving median
moving_mean <- function(x, width = 5) {
  n_time <- nrow(x)
  n_pixels <- ncol(x)

  # Pre-allocate result matrix
  result <- matrix(NA_real_, nrow = n_time, ncol = n_pixels)

  # Calculate half-window size for centering
  half_width <- floor(width / 2)

  # For each time step where we can compute a full window
  for (t in (half_width + 1):(n_time - half_width)) {
    window_idx <- (t - half_width):(t + half_width)
    result[t, ] <- colMeans(x[window_idx, , drop = FALSE], na.rm = TRUE)
  }

  return(result)
}

  smoothed <- singleband_m2m(
    collection,
    m2m_fun = moving_mean,
    recollect = TRUE
  )


withr::with_par(list(mfrow = c(1, 2)), {
  plot(collection, item = 10, bands = c(3, 2, 1), main = "Original")
  plot(smoothed, item = 10, bands = c(3, 2, 1), main = "5-Image Moving Mean")
})
\dontshow{\}) # examplesIf}
}
\seealso{
\code{\link[=hampel_filter]{hampel_filter()}} for outlier detection, \code{\link[=vrt_warp]{vrt_warp()}} to prepare
aligned collections, \code{\link[=vrt_derived_block]{vrt_derived_block()}} for band math before filtering
}
