% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/vrt-set-mask.R, R/zvrt-pixel-funs-mask.R
\name{vrt_set_maskfun}
\alias{vrt_set_maskfun}
\alias{vrt_set_maskfun.vrt_block}
\alias{vrt_set_maskfun.vrt_collection}
\alias{set_mask_numpy}
\alias{build_intmask}
\alias{build_bitmask}
\alias{build_omnicloudmask}
\title{Set mask band of a VRT collection}
\usage{
vrt_set_maskfun(
  x,
  mask_band,
  mask_values,
  build_mask_pixfun,
  set_mask_pixfun,
  drop_mask_band,
  cache_dir
)

\method{vrt_set_maskfun}{vrt_block}(
  x,
  mask_band,
  mask_values,
  build_mask_pixfun = vrtility::build_intmask(),
  set_mask_pixfun = vrtility::set_mask_numpy(),
  drop_mask_band = TRUE,
  cache_dir = getOption("vrt.cache")
)

\method{vrt_set_maskfun}{vrt_collection}(
  x,
  mask_band,
  mask_values,
  build_mask_pixfun = vrtility::build_intmask(),
  set_mask_pixfun = vrtility::set_mask_numpy(),
  drop_mask_band = TRUE,
  cache_dir = getOption("vrt.cache")
)

set_mask_numpy()

build_intmask()

build_bitmask()

build_omnicloudmask(
  red,
  green,
  nir,
  patch_size = 600,
  patch_overlap = 300,
  batch_size = 1,
  no_data_value = 0,
  inference_device = NULL
)
}
\arguments{
\item{x}{A VRT collection}

\item{mask_band}{The name of the mask band}

\item{mask_values}{A numeric vector of integer or bit values to be masked.}

\item{build_mask_pixfun}{A character string of the Python code to build the
mask. Provided functions include \code{\link[=build_intmask]{build_intmask()}} and \code{\link[=build_bitmask]{build_bitmask()}}.
See details.}

\item{set_mask_pixfun}{A character string of the Python code to set the mask.
Provided functions include \code{\link[=set_mask_numpy]{set_mask_numpy()}}. See
details.}

\item{drop_mask_band}{Logical. If TRUE, the mask band will be removed from
the VRT block.}

\item{cache_dir}{A character string of the directory to use for temporary
files. In general this should be left alone. main purpose is to manage cache
location when running asyncronously with mirai.}

\item{red}{The red band index (numeric or integer).}

\item{green}{The green band index (numeric or integer).}

\item{nir}{The near-infrared band index (numeric or integer).}

\item{patch_size}{The size of the patches to use for prediction (numeric or
integer, default: 600).}

\item{patch_overlap}{The overlap between patches (numeric or integer,
default: 300).}

\item{batch_size}{The batch size to use for prediction (numeric or integer,
default: 1).}

\item{no_data_value}{The value to use for no data pixels
(numeric, default: 0).}

\item{inference_device}{The device to use for inference. If \code{NULL}, the
function will automatically select the best available device (character,
default: \code{NULL}). Options include "cpu", "cuda", "mps", etc. The order of
selection is based on availability: "cuda" > "mps" > "cpu".}
}
\value{
A VRT block with the mask band set.

A VRT collection with the mask band set.

A Python function that can be used as a pixel function in a VRT
raster. The function will apply the OmniCloudMask model to the specified
bands and create a cloud mask.
}
\description{
This function constructs a cloud mask using the OmniCloudMask
python library. It is designed to be used with the \code{vrt_set_maskfun()}
function.
}
\details{
The \code{build_mask_pixfun} function is used to build the mask band. Where the
mask band is a true bitmask and bit-wise operations are required, the
\code{\link[=build_bitmask]{build_bitmask()}} function should be used. For integer-based masking, where
the mask band is provided as a single band with integer values, the
\code{\link[=build_intmask]{build_intmask()}} function should be used.

The \code{set_mask_pixfun} function is used to apply the mask to the other bands.
In general \code{\link[=set_mask_numpy]{set_mask_numpy()}} should be used, although a custom function can
be provided.

\code{set_mask_numpy} simply applies a given mask where values of 0 are
assumed to have nodata and values > 0 (typically 255) contain valid data.
It is the only provided function for the \code{set_mask_pixfun} argument in
\code{vrt_set_maskfun()}. Alternatively a custom function could be provided if,
for example a user wishes to buffer the mask.

\code{build_intmask} provides an integer mask function that can be used
to mask out pixels based on a band containing true integer/numeric values.
This would be appropriate for the Sentinel 2A SCL band, for example.

\code{build_bitmask} provides is a simple bit-wise mask function that can
be used to mask out pixels based on a true bit mask. This function should be
used where bitwise operations are required. e.g. for HLS data, the "Fmask"
band requires bitwise operations to extract the mask values.
}
\examples{
s2files <- fs::dir_ls(system.file("s2-data", package = "vrtility"))

ex_collect <- vrt_collect(s2files)
ex_collect |>
  vrt_set_maskfun(
    mask_band = "SCL",
    mask_values = c(0, 1, 2, 3, 8, 9, 10, 11),
    drop_mask_band = FALSE)

}
