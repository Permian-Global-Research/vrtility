% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/vrt-set-mask.R, R/zvrt-pixel-funs-mask.R
\name{vrt_set_maskfun}
\alias{vrt_set_maskfun}
\alias{vrt_set_maskfun.vrt_block}
\alias{vrt_set_maskfun.vrt_collection}
\alias{build_intmask}
\alias{build_bitmask}
\title{Set mask band of a VRT collection}
\usage{
vrt_set_maskfun(
  x,
  mask_band,
  mask_values,
  build_mask_pixfun = NULL,
  buffer_size = 0,
  drop_mask_band = TRUE
)

\method{vrt_set_maskfun}{vrt_block}(
  x,
  mask_band,
  mask_values,
  build_mask_pixfun = NULL,
  buffer_size = 0,
  drop_mask_band = TRUE
)

\method{vrt_set_maskfun}{vrt_collection}(
  x,
  mask_band,
  mask_values,
  build_mask_pixfun = NULL,
  buffer_size = 0,
  drop_mask_band = TRUE
)

build_intmask(use_muparser = getOption("vrtility.use_muparser", FALSE))

build_bitmask(use_muparser = getOption("vrtility.use_muparser", FALSE))
}
\arguments{
\item{x}{A VRT collection}

\item{mask_band}{The name of the mask band}

\item{mask_values}{A numeric vector of integer or bit values to be masked.}

\item{build_mask_pixfun}{A character string of the Python code or muparser
expression to build the mask. If \code{NULL} (default), automatically uses
\code{\link[=build_intmask]{build_intmask()}} which will choose muparser if the option \code{vrtility.use_muparser}
is \code{TRUE} with no buffering, otherwise a Python based implementation is used.
Provided functions include \code{build_intmask} and \code{build_bitmask}. See details.}

\item{buffer_size}{A buffer size to apply to the mask (numeric, default: 0). A buffer
size > 0 will dilate the mask by the specified number of pixels.
This can be useful to remove edge effects around clouds.
If a buffer size > 0 is specified, the \code{scipy} python library will
automatically be installed and Python will be used (muparser cannot do buffering).}

\item{drop_mask_band}{Logical. If TRUE, the mask band will be removed from
the VRT block.}

\item{use_muparser}{Logical. If \code{TRUE} and GDAL >= 3.12, uses muparser}
}
\value{
A VRT block with the mask band set.

A VRT collection with the mask band set.
}
\description{
Set mask band of a VRT collection
}
\details{
The \code{build_mask_pixfun} function is used to build the mask band. Where the
mask band is a true bitmask and bit-wise operations are required, the
\code{\link[=build_bitmask]{build_bitmask()}} function should be used. For integer-based masking, where
the mask band is provided as a single band with integer values, the
\code{\link[=build_intmask]{build_intmask()}} function should be used.

By default (when \code{build_mask_pixfun = NULL}), the function automatically
selects the most efficient implementation:
\itemize{
\item GDAL >= 3.12 with no buffering: Uses muparser expressions (fastest, no Python)
\item GDAL < 3.12 or buffering needed: Uses Python/NumPy
}

\code{build_intmask} provides an integer mask function that can be used
to mask out pixels based on a band containing true integer/numeric values.
This would be appropriate for the Sentinel 2A SCL band, for example.

\code{build_bitmask} provides is a simple bit-wise mask function that can
be used to mask out pixels based on a true bit mask. This function should be
used where bitwise operations are required. e.g. for HLS data, the "Fmask"
band requires bitwise operations to extract the mask values.
}
\examples{
s2files <- fs::dir_ls(system.file("s2-data", package = "vrtility"))

ex_collect <- vrt_collect(s2files)

# Auto-selects muparser or Python based on GDAL version
ex_collect |>
  vrt_set_maskfun(
    mask_band = "SCL",
    mask_values = c(0, 1, 2, 3, 8, 9, 10, 11),
    drop_mask_band = FALSE)

# Force Python implementation
ex_collect |>
  vrt_set_maskfun(
    mask_band = "SCL",
    mask_values = c(0, 1, 2, 3, 8, 9, 10, 11),
    build_mask_pixfun = build_intmask(),
    drop_mask_band = FALSE)

}
